# The Craftr build system
# Copyright (C) 2016  Niklas Rosenstein
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

cxx = load('craftr.lang.cxx')
c4d = load('NiklasRosenstein.maxon.c4d')
dlib = load('craftr.lib.dlib').dlib
cpp_nr = load('NiklasRosenstein.cpp-nr').nr
webp = load('nr_toolkit.webp').webp
git = load('craftr.utils.git').Git(project_dir)


# ============================================================================
# GIT
# ============================================================================

def write_gitversion():
  filename = buildlocal('include/GIT_VERSION.h')
  dirname = path.dirname(filename)
  if session.builddir:
    path.makedirs(dirname)
    description = git.describe()
    with open(filename, 'w') as fp:
      fp.write('#pragma once\n#define GIT_VERSION "{}"\n'.format(description))
  return dirname

gitversion_dir = write_gitversion()

# ============================================================================
# Components Base
# ============================================================================

class Component(object):
  """
  Represents a component of the nr-toolbox plugin that is to be compiled
  into the plugin. Every component lists the source files that it needs
  compiled, a preprocessor definition that will be set when the component
  is enabled and a list of files that are to be included when packaging
  the plugin.
  """

  instances = []

  def __init__(self, name, defines=(), files=(), descriptions=(),
               sources=(), enabled=True, frameworks=[]):
    self.name = name
    self.defines = ["HAVE_" + name.upper()] + list(defines)
    self.files = list(files)
    self.descriptions = descriptions
    self.sources = sources
    self.enabled = enabled
    self.frameworks = frameworks

  def __repr__(self):
    return 'Component({})'.format(self.name)

class ComponentList(object):

  def __init__(self):
    self.components = []

  def __iter__(self):
    return iter(filter(lambda x: x.enabled, self.components))

  def add(self, *args, **kwargs):
    self.components.append(Component(*args, **kwargs))
    return self

  def defines(self):
    result = []
    for comp in self:
      if comp.enabled:
        result.append('HAVE_' + comp.name.upper())
    return result

  def compile_all(self, include, frameworks=(), **options):
    result = []
    defines = self.defines()
    for comp in self:
      if not comp.enabled:
        continue
      target = cxx.compile_cpp(
        sources = comp.sources,
        include = include,
        defines = comp.defines + defines,
        frameworks = comp.frameworks + list(frameworks),
        name = 'objects_' + comp.name,
        exceptions = True,
        **options
      )
      result.append(target)
    return result

def glob_descriptions(pattern):
  result = glob(['plugin/res/description/' + pattern + '.h'])
  return [path.rmvsuffix(path.basename(x)) for x in result]

# ============================================================================
# Component Declaration
# ============================================================================

components = (ComponentList()
  .add("main",
    sources=map(local, ['source/main.cpp', 'source/menu.cpp', 'source/config.cpp'])
  )
  .add("autoconnect",
    sources=[local('source/autoconnect.cpp')],
  )
  .add("commands",
    sources=glob(['source/commands/*.cpp'])
  )
  .add("colorpalette",
    sources=glob(['source/colorpalette/*.cpp']),
    descriptions=['Xnrswatch']
  )
  .add("depmanager",
    sources=glob(['source/depmanager/*.cpp'])
  )
  .add("pr1mitive",
    sources=glob(['source/pr1mitive/**/*.cpp']),
    descriptions=glob_descriptions('?pr1m*'),
    defines=['PRMT'],
  )
  .add("procedural",
    enabled=False,
    sources=glob(['source/procedural/**/*.cpp']),
    descriptions=glob_descriptions('nrprocedural_*')
  )
  .add("smeardeformer",
    sources=glob(['source/smeardeformer/**/*.cpp']),
    descriptions=glob_descriptions('W*') + glob_descriptions('S*') + ['Oxpressoeffector']
  )
  .add("teapresso",
    enabled=False,
    sources=glob(['source/teapresso/*.cpp']),
    descriptions=glob_descriptions('Tv*')
  )
  .add("nrworkflow",
    sources=glob(['source/nrworkflow/*.cpp']),
    descriptions=['Htoolbox']
  )
  .add("xpe",
    sources=glob(['source/xpe/*.cpp']),
    files=map(local, ['plugin/res/xpe-preset.c4d']),
    descriptions=['Gvcsv', 'Gvmodata', 'Ocsveffector', 'Oxpressoeffector']
  )
  .add("webpio",
    sources=map(local, ['source/webpio.cpp']),
    frameworks=[webp]
  )
)

# ============================================================================
# Compilation Targets
# ============================================================================

compile_settings = Framework('settings',
  std = 'c++11',
  exceptions = True,
  llvm_additional_flags = ['-Wno-shadow', '-Wno-missing-prototypes'],
  frameworks = [c4d.sdk, dlib, cpp_nr]
)

if platform.name == 'win':
  compile_settings['defines'] = ['_CRT_SECURE_NO_WARNINGS']
  compile_settings['forced_include'] = ['eh.h']  # temporary MSVC fix
  compile_settings['exceptions'] = True

objects = components.compile_all(
  include = map(local, ['plugin', 'include', 'source']) + [gitversion_dir],
  frameworks = [compile_settings],
)

plugin = cxx.shared_library(
  output = local('plugin/nr-toolkit'),
  inputs = objects
)

serial_bin = cxx.executable(
  inputs = objects + [cxx.compile_cpp(
    sources = map(local, ['pr1mitive_serial_main.cpp']),
    include = [local('source')]
  )],
  output = 'pr1mitive_serial_main'
)
#serial_bin.explicit = True
serial = runtarget(serial_bin)
